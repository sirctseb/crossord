isCurrentUser(userId) {
    return auth != null && auth.uid == userId;
}

type Matrix<Type> extends Map<Index, Map<Index, Type>>;
type Presence<Type> extends Map<Type, Boolean>;
type CurrentUser extends UserId {
    validate() {
        isCurrentUser(this);
    }
}

/*
 * Core crossword document content types
 */
type Crossword {
    rows: Number
    symmetric: Boolean
    themeEntries: Boolean[]
    clues: Map<Direction, Matrix<String>>
    boxes: Matrix<Box>
    title: String | Null

    read() {
        auth.uid == root.permissions[key()].owner ||
        root.permissions[key()].collaborators[auth.uid]
    }

    create() {
        auth.uid == root.permissions[key()].owner
        && root.users[auth.uid].crosswords[key()] != null
    }

    delete() {
        auth.uid == root.permissions[key()].owner
    }

    update() {
        auth.uid == root.permissions[key()].owner ||
        root.permissions[key()].collaborators[auth.uid]
    }
}

// Subtype of String restricted to valid integers. This helps to ensure
// that a Map from this type will act well as an array
type Index extends String {
    validate() {
        this.test(/^[0-9]+$/)
    }
}

type Direction extends String {
    validate() {
        this.test(/(across|down)/)
    }
}

type Box {
    blocked: Boolean | Null,
    circled: Boolean | Null,
    shaded: Boolean | Null,
    content: String | Null,
}

path /crosswords is Crossword[] {}

/*
 * Crossword metadata and types for authoring features
 */
type CrosswordMetadata {
    title: String | Null,
}

type WordlistEntry {
    word: String,
    usedBy: Presence<CrosswordId>,
}

// ok product: user's have an associated image which is:
// 1. a photo they have uploaded to our site if they have uploaded it OR
// 2. a photoUrl from their auth object if it exists OR
// 3. a gravatar keyed by their email OR
// 4. a random checkerbox pattern. basically a github one but black and white
//
// this can't really be pure client logic because we're showing avatars for other users,
// and this logic would depend on knowing their email. we don't have or want other user
// email addresses coming down
//
// so what are the times when we set the url?
// 1. when the upload a photo => immediately set it
// 2.
//
// also, can they clear the image if it came from 2,3,4?
// wait, wait, wait. auth always has a photoUrl AND you can modify it
// so for cursors, e.g., we should just set the url in decorateCursor with the photoUrl
// what about rendering, e.g. a friends list, or the author of some public cw?
// we don't just have the auth object to look up the photo at query time
// so for any given feature we need to stash that url into the data needed for the feature?
//  - that doesn't make sense for friends list, where the list maker is not the
//    person with the photourl
//

/*
 * User info, profile, and preferences
 */
type User {
    crosswords: CrosswordMetadata[],
    wordlist: WordlistEntry[],

    avatarUrl: String | Null,

    write() {
        key() == auth.uid
    }
    read() {
        key() == auth.uid
    }
}

path /users is User[] {}

/*
 * Permissions
 */
type Permissions {
    owner: UserId,
    collaborators: Presence<UserId>,
    global: Boolean | Null,

    create() {
        auth.uid != null &&
        auth.uid == this.owner
    }
    update() {
        auth.uid == this.owner
    }
    delete() {
        auth.uid == this.owner
    }
    validate() {
        this.owner == auth.uid &&
        (
            prior(this.owner) == null ||
            this.owner == prior(this.owner)
        )
    }
}

// would like to be able to ensure this user exists but we don't own that list
type UserId extends String {}

type CrosswordId extends String {
    validate() {
        root.crosswords[key()] != null
    }
}

path /permissions is Map<CrosswordId, Permissions> {}

/*
 * Cursors
 */
type Cursor {
    userId: CurrentUser

    row: Number | Null
    column: Number | Null

    // fanout cursor owner info for display
    userDisplayName: String | Null
    userAvatarUrl: String | Null

    write() {
        auth.uid == this.userId || auth.uid == prior(this.userId)
    }
}

// would rather specify the path this way, but then we can't access the cw id key
// from the cursor key object level
// path /cursors is Map<CrosswordId, Cursor[]> {
path /cursors/{cwid} is Cursor[] {
    validate() {
        root.crosswords[key()] != null
    }

    read() {
        auth.uid == root.permissions[cwid].owner ||
        root.permissions[cwid].collaborators[auth.uid]
    }
}
